#include <stdio.h>
#define MOD 998244353

// 快速幂计算 a^b mod MOD
long long quick_pow(long long a, long long b) {
    long long result = 1;
    long long base = a % MOD; // 先对a取模，避免大数溢出
    
    while (b > 0) {
        // 若当前指数的二进制最低位为1，将结果乘上当前底数
        if (b & 1) { // 等价于 b%2 == 1
            result = (result * base) % MOD;
        }
        // 底数平方（对应指数右移一位）
        base = (base * base) % MOD;
        // 指数右移一位（等价于除以2）
        b >>= 1;
    }
    
    // 处理特殊边界：0^0（题目中a,b均为0时，结果按0处理）
    if (a == 0 && b == 0) {
        return 0;
    }
    return result;
}

int main() {
    long long a, b;
    scanf("%lld %lld", &a, &b);
    printf("%lld\n", quick_pow(a, b));
    return 0;
}




#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, pos = 0;  // pos：当前报数的位置索引
    int *num;

    printf("请输入这一圈人的数量:\n");
    scanf("%d", &n);

    // 动态分配数组（支持任意人数）
    num = (int *)malloc(n * sizeof(int));
    if (num == NULL) {
        printf("内存分配失败！\n");
        return 1;
    }

    // 1. 初始化编号（1~n）
    for (int i = 0; i < n; i++) {
        num[i] = i + 1;
    }

    // 2. 核心逻辑：for循环控制出列n-1人（直观体现“要淘汰多少人”）
    for (int out = 0; out < n - 1; out++) {  // out：已出列人数
        // 找到下一个报数为3的人（跳过已出列的0）
        for (int count = 0; count < 3; pos = (pos + 1) % n) {
            if (num[pos] != 0) {  // 未出列的人才报数
                count++;  // 报数+1
            }
        }
        // 此时pos指向的人报数为3，标记为出列（置0）
        num[pos] = 0;
    }

    // 3. 输出最后留下的人
    printf("现在剩下的人是:");
    for (int i = 0; i < n; i++) {
        if (num[i] != 0) {
            printf("%2d号\n", num[i]);
        }
    }

    free(num);
    return 0;
}






#include <stdio.h>
#include <stdbool.h>

// 判断一个数是否是质数
bool isPrime(long long num) {
    if (num <= 1) return false;
    if (num == 2) return true;
    if (num % 2 == 0) return false;
    for (long long i = 3; i * i <= num; i += 2) {
        if (num % i == 0) return false;
    }
    return true;
}

// 质因数分解，并返回质因数及其指数
void primeFactorization(long long n, long long factors[], int exponents[], int *count) {
    *count = 0; // 质因数的个数
    long long temp = n;

    // 处理 2 的情况
    if (temp % 2 == 0) {
        factors[*count] = 2;
        exponents[*count] = 0;
        while (temp % 2 == 0) {
            exponents[*count]++;
            temp /= 2;
        }
        (*count)++;
    }

    // 处理奇数因子
    for (long long i = 3; i * i <= temp; i += 2) {
        if (temp % i == 0) {
            factors[*count] = i;
            exponents[*count] = 0;
            while (temp % i == 0) {
                exponents[*count]++;
                temp /= i;
            }
            (*count)++;
        }
    }

    // 如果最后剩下的数是一个质数
    if (temp > 1) {
        factors[*count] = temp;
        exponents[*count] = 1;
        (*count)++;
    }
}

// 验证分解结果的唯一性
bool verifyUniqueness(long long n, long long factors[], int exponents[], int count) {
    long long product = 1;
    for (int i = 0; i < count; i++) {
        for (int j = 0; j < exponents[i]; j++) {
            product *= factors[i];
        }
    }
    return product == n;
}

int main() {
    long long num;
    printf("请输入一个大于 1 的整数：");
    scanf("%lld", &num);

    if (num <= 1) {
        printf("输入错误！请输入大于 1 的整数。\n");
        return 1;
    }

    long long factors[20];   // 存储质因数
    int exponents[20];       // 存储对应指数
    int count;               // 质因数的个数

    // 分解质因数
    primeFactorization(num, factors, exponents, &count);

    // 输出分解结果
    printf("%lld 的质因数分解为：\n", num);
    for (int i = 0; i < count; i++) {
        printf("%lld^%d", factors[i], exponents[i]);
        if (i < count - 1) {
            printf(" × ");
        }
    }
    printf("\n");

    // 验证唯一性
    if (verifyUniqueness(num, factors, exponents, count)) {
        printf("验证通过：分解结果的乘积等于原数，满足唯一质因数分解定理。\n");
    } else {
        printf("验证失败：分解结果的乘积不等于原数！\n");
    }

    return 0;
}


