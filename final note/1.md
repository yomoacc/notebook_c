//打印8/16进制 %o %x,定义0 0x
整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）
//命名时， 只能以字母或下划线开始；
//strlen可见字符数量，sizeof all    char *str = malloc(strlen("hello") + 1); // +1 是为了 '\0'
//只是单纯存 5 个字符，不调用任何字符串处理函数,可以不用 \0。char data[5] = {'a', 'b', 'c', 'd', 'e'};字符串数组给'\0'多留一个位置；
//文件i/o ???
//*(*(arr + i) + j);
int *p = &arr[0][0][0];
for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 3; j++) {
        for (int k = 0; k < 4; k++) {
            printf("%d ", *(p + i * 12 + j * 4 + k)); // 总偏移量
        }
        printf("\n");
    }
    printf("---\n");
}
偏移量计算公式：i * N * P + j * P + k。
//while() 判定的是赋值表达式的结果值，而不是 “语句” 本身。一切非零值，'\0',0.0不可以
//二维数组中，arr 是第一行的地址（类型 int (*)[4]），&arr 是整个二维数组的地址（类型 int (*)[3][4]）。
它们的数值地址相同，但类型不同，导致指针运算的步长不同。数值相同arr==&arr;
//冒泡 i j=0 j<n-1-i. 先尾最大 i j=n-1 j>i   先头最小   (从大到小拍就反过来判定j和j+1)
//c科学计数法 
double num = 1.23e4;  // 1.23 × 10^4 = 12300.0
double num2 = 5.67e-3; // 5.67 × 10^-3 = 0.00567    打印格式%e / %le
//(num >> i) & 1 获取进制的位上数
void printBinary(unsigned int num) {
    for (int i = 31; i >= 0; i--) {
        printf("%d", (num >> i) & 1); // 从高位到低位依次提取
    }
    printf("\n");                       //打印二进制数
}
//字符转ascii码 %c %d a=65 A=97;
//%-d左对齐，默认给定宽度右对齐
//ifelse嵌套 grade=(score>=90)?'A':((score>=60)?'B':'C');哈哈哈
   
